Object subclass: #Caerus	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Caerus class	instanceVariableNames: ''!!Caerus class methodsFor: 'accessing' stamp: 'BenoitStJean 3/11/2019 20:56'!version	^0.02! !Object subclass: #Move	instanceVariableNames: 'hashKey from to ply captured score sideToMove'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!Move commentStamp: 'BenoitStJean 1/2/2019 22:20' prior: 0!I represent a possible move for a position that can be made an unmade easily to revert the position back to what it was without the need of copying structures all over the place.  I am created by the MoveGeneratorInstance variables:hashKey 	<LargePositiveInteger>		Not used for nowfrom 		<Integer>					Square index of source square on board of <Position>, [ 1..25 ]to 			<Integer>					Square index of target  square on board of <Position>, [ 1..25 ]ply 			<SmallInteger>				Move number in plies captured 	<BlueStone | RedStone | nil>	Captured piece, if anyscore 		<Float>						Score of <Position> for move, [ 0.00 .. 1.00 ]sideToMove 	<#RED | #BLUE>				Side that is executing the current <Move>!!Move methodsFor: 'comparing' stamp: 'BenoitStJean 1/2/2019 15:03'!= anObject	anObject class == self class ifFalse: [ ^false ].		anObject 	hashKey = self hashKey ifFalse: [ ^false ]. 	anObject from = self from ifFalse: [ ^false ]. 	anObject to = self to ifFalse: [ ^false ]. 	anObject captured = self captured ifFalse: [ ^false ]. 	anObject sideToMove = self sideToMove ifFalse: [ ^false ].	anObject ply = self ply ifFalse: [ ^false ]. 	anObject score = self score ifFalse: [ ^false ].		^true! !!Move methodsFor: 'comparing' stamp: 'BenoitStJean 1/31/2019 12:04'!hash		^(from bitXor: to) bitXor: sideToMove hash! !!Move methodsFor: 'printing' stamp: 'BenoitStJean 12/10/2018 06:10'!printOn: aStream	| delimiter |		delimiter := self isCapture ifTrue: [ $x ] ifFalse: [ $- ].	aStream 		nextPutAll: from asSquare;		nextPut: delimiter;		nextPutAll: to asSquare.! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:49'!isEnemyCapture	^self sideToMove == #RED		ifTrue: [ self isBlueStoneCapture ]		ifFalse: [ self isRedStoneCapture ]! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:05'!isBlueStoneCapture	^captured isBlueStone ! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:21'!isRedMove	^sideToMove == #RED! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:21'!isBlueMove	^self isRedMove not! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:44'!isKillerFor: aPosition	^aPosition isKillerMove: self! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:05'!isCapture	^captured isStone! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:49'!isFriendlyCapture	^self sideToMove == #BLUE		ifTrue: [ self isBlueStoneCapture ]		ifFalse: [ self isRedStoneCapture ]! !!Move methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:05'!isRedStoneCapture	^captured isRedStone ! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:03'!ply: anInteger	ply := anInteger! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:01'!to	^to! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:05'!captured	^captured! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:03'!ply	^ply! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:04'!sideToMove	^sideToMove! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:01'!from: anInteger	from := anInteger! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:06'!score: aFloat	score := aFloat! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 13:44'!hashKey: anInteger	hashKey := anInteger! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:05'!captured: aStone	captured := aStone! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 13:44'!hashKey	^hashKey! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:05'!score	^score! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:00'!from	^from! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:01'!to: anInteger	to := anInteger! !!Move methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 14:04'!sideToMove: aSymbol	sideToMove := aSymbol! !Object subclass: #MoveGenerator	instanceVariableNames: 'position'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!MoveGenerator commentStamp: 'BenoitStJean 1/24/2019 01:17' prior: 0!I am responsible for <Move> creation from a <Position>.  All I know and can do is:1) create moves based on a roll2) create moves for a <Stone>3) create all available move in a <Position> regardless of the roll!!MoveGenerator methodsFor: 'accessing' stamp: 'BenoitStJean 12/27/2017 13:09'!position	^ position! !!MoveGenerator methodsFor: 'accessing' stamp: 'BenoitStJean 12/27/2017 13:09'!position: anObject	position := anObject! !!MoveGenerator methodsFor: 'generating-moves' stamp: 'BenoitStJean 1/24/2019 01:46'!movesForStone: aStone	| source moves|		"hashKey from to ply captured score sideToMove"		moves := OrderedCollection new: 3.	source := position squareOfStone: aStone.	source isNil ifTrue: [ self error: 'Should not get here!!' ].		(position canMoveEast: aStone) 		ifTrue: [| m dest |					dest := source + 1.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].	(position canMoveWest: aStone) 		ifTrue: [| m dest |					dest := source - 1.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].					(position canMoveSouth: aStone) 		ifTrue: [| m dest |					dest := source - 5.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].					(position canMoveNorth: aStone) 		ifTrue: [| m dest |					dest := source + 5.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].		(position canMoveSouthEast: aStone) 		ifTrue: [| m dest |					dest := source - 4.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].					(position canMoveNorthWest: aStone) 		ifTrue: [| m dest |					dest := source + 4.					m := Move new.					m from: source.					m to: dest.					m ply: position moveNumber.					m captured: (position basicAt: dest).					m sideToMove: position sideToMove.					m hashKey: position calculateHashKey.					moves add: m.					 ].	^moves		! !!MoveGenerator methodsFor: 'generating-moves' stamp: 'BenoitStJean 1/31/2019 11:08'!movesForRoll	| moves |		moves := OrderedCollection new: 6.	position stonesForRoll do: [ :each | moves addAll: (self movesForStone: each) ].	^moves	! !!MoveGenerator methodsFor: 'generating-moves' stamp: 'BenoitStJean 1/24/2019 01:47'!allPossibleMoves	| allMoves |		self flag: #toBeOptimizedForStones.	allMoves := Set new: 18.	1 to: 6 do: [ :roll | allMoves addAll: (self movesForRoll: roll) ].	^allMoves asOrderedCollection 	! !!MoveGenerator methodsFor: 'generating-moves' stamp: 'BenoitStJean 1/24/2019 01:46'!movesForRoll: anInteger	| moves |		moves := OrderedCollection new: 6.	(position stonesForRoll: anInteger) do: [ :each | moves addAll: (self movesForStone: each) ].	^moves	! !!MoveGenerator methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/3/2019 08:40'!stonesForRoll: anInteger		^position stonesForRoll: anInteger.! !!MoveGenerator methodsFor: 'initialize-release' stamp: 'BenoitStJean 1/3/2019 09:48'!initialize	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MoveGenerator class	instanceVariableNames: ''!!MoveGenerator class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/3/2019 09:47'!new	^super new! !!MoveGenerator class methodsFor: 'instance-creation' stamp: 'BenoitStJean 12/10/2018 05:42'!on: aPosition	| instance |		instance := self basicNew.	instance position: aPosition.	^instance! !Object subclass: #Position	instanceVariableNames: 'sideToMove board blueStonesMoveNorth moveNumber blueStones redStones roll hashKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!Position commentStamp: 'BenoitStJean 11/15/2018 04:49' prior: 0!Internally, stones are represented by integers.  South stones [ 1..6] and north stones [ -1..-6].Instance variables:sideToMove 	<Symbol> 			Either #SOUTH or #NORTH.  Indicates who's players turn isboard 		<Array of Integer>	Holds all squares & their stones contentnorthStones 	<Array of Integer>	Holds square locations of all 6 north stonessouthStones <Array of Integer>		Holds square locations of all 6 south stones!!Position methodsFor: 'copying' stamp: 'BenoitStJean 2/1/2019 13:01'!copy	^(self class basicNew)		sideToMove: sideToMove;		privateSetBoard: board deepCopy;		blueStonesMoveNorth: blueStonesMoveNorth;		moveNumber: moveNumber;		privateSetBlueStones: blueStones copy;		privateSetRedStones: redStones copy;		roll: roll;		hashKey: hashKey;		yourself! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/24/2019 17:20'!canMoveSouth: aStone	(self isMovingTowardsSouth: aStone) ifFalse: [ ^false ].	^(self class row1 includes: (self squareOfStone: aStone)) not! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/24/2019 17:20'!canMoveNorth: aStone	(self isMovingTowardsNorth: aStone) ifFalse: [ ^false ].	^(self class row5 includes: (self squareOfStone: aStone)) not	! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 12/31/2018 10:23'!canMoveNorthEast: aStone	^false! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/24/2019 17:18'!canMoveWest: aStone	(self isMovingTowardsSouth: aStone) ifTrue: [ ^false ].	^(self class columnA includes: (self squareOfStone: aStone)) not! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/24/2019 17:19'!canMoveEast: aStone	(self isMovingTowardsNorth: aStone) ifTrue: [ ^false ].	^(self class columnE includes: (self squareOfStone: aStone)) not! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/31/2019 19:35'!canMoveNorthWest: aStone		(self isMovingTowardsNorth: aStone) ifFalse: [ ^false ].	(self class columnA includes: (self squareOfStone: aStone)) ifTrue: [ ^false ].	(self class row5 includes: (self squareOfStone: aStone)) ifTrue: [ ^false ].	^true! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 11/27/2018 12:21'!isMovingTowardsNorth: aStone		(aStone isBlueStone and: [blueStonesMoveNorth]) ifTrue: [ ^true ].	(aStone isRedStone and: [blueStonesMoveNorth not]) ifTrue: [ ^true ].	^false! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 11/27/2018 12:34'!isMovingTowardsSouth: aStone		^(self isMovingTowardsNorth: aStone) not! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 12/31/2018 10:23'!canMoveSouthWest: aStone	^false! !!Position methodsFor: 'testing-stone direction' stamp: 'BenoitStJean 1/31/2019 19:35'!canMoveSouthEast: aStone	(self isMovingTowardsSouth: aStone) ifFalse: [ ^false ].	(self class columnE includes: (self squareOfStone: aStone)) ifTrue: [ ^false ].	(self class row1 includes: (self squareOfStone: aStone)) ifTrue: [ ^false ].	^true! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 11/27/2018 09:07'!redStonesDirection	^blueStonesMoveNorth 		ifTrue: [ #SOUTH ]		ifFalse: [ #NORTH ]! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 12/6/2018 03:41'!decrementMoveNumber	moveNumber := moveNumber - 1.! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/21/2019 15:07'!blueStonesMove: aSymbol	aSymbol == #BLUE ifTrue: [ ^self blueStonesMoveNorth: true ].	aSymbol == #RED ifTrue: [ ^self blueStonesMoveNorth: false ].	self error: 'Invalid color symbol as argument <aSymbol>!!'! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/2/2019 21:51'!targetSquareForColor: aSymbol	aSymbol == #RED ifTrue: [ ^self redStonesDirection == #NORTH ifTrue: [ 21 ] ifFalse: [ 5 ] ].	aSymbol == #BLUE ifTrue: [ ^self blueStonesDirection == #NORTH ifTrue: [ 21 ] ifFalse: [ 5 ] ].		^self error: 'Should not get here!!'! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 12/6/2018 03:40'!incrementMoveNumber	moveNumber := moveNumber + 1.! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 11/27/2018 09:07'!blueStonesDirection	^blueStonesMoveNorth 		ifTrue: [ #NORTH ]		ifFalse: [ #SOUTH ]! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 12/6/2018 03:39'!flipSideToMove	(sideToMove = #BLUE) 		ifTrue: [ sideToMove := #RED ]		ifFalse: [ 	(sideToMove = #RED)							ifTrue: [ sideToMove := #BLUE ]							ifFalse: [ self error: 'Should not get here' ]	].! !!Position methodsFor: 'accessing-derived' stamp: 'BenoitStJean 11/27/2018 11:47'!squareOfStone: aStone	aStone isBlueStone ifTrue: [ ^blueStones at: aStone number ].	aStone isRedStone ifTrue: [ ^redStones at: aStone number ].	self error: 'Should not get here!!'! !!Position methodsFor: 'printing' stamp: 'BenoitStJean 1/3/2019 17:15'!basicPrintShortPenStringOn: aStream	| squares stmChar bsdChar rollChar mvNumber |		squares := #(21 22 23 24 25 16 17 18 19 20 11 12 13 14 15 6 7 8 9 10 1 2 3 4 5).	squares doWithIndex: [ :sq :idx | aStream nextPut: (self basicAt: sq) penCharacter.												(idx \\ 5) = 0 ifTrue: [ aStream nextPut: $/ ] ].												stmChar := (self sideToMove = #RED) ifTrue: [ $R ] ifFalse: [ $B ].	aStream nextPut: stmChar;nextPut: $/.		bsdChar := (self blueStonesDirection = #NORTH) ifTrue: [ $N ] ifFalse: [ $S ].	aStream nextPut: bsdChar;nextPut: $/.	rollChar := self roll isNil ifTrue: [ $* ] ifFalse: [ self roll printString first ].	aStream nextPut: rollChar;nextPut: $/.		mvNumber := self moveNumber isNil ifTrue: [ '*' ] ifFalse: [ self moveNumber printString ].	aStream nextPutAll: mvNumber.! !!Position methodsFor: 'printing' stamp: 'BenoitStJean 1/3/2019 17:11'!basicPrintBoardWithDetailsOn: aStream		self basicPrintBoardOn: aStream.	aStream 		nextPutAll: 'Side to move: ';		nextPutAll: sideToMove;		cr;		nextPutAll: 'Blue is moving: ';		nextPutAll: self blueStonesDirection;		cr;		nextPutAll: 'Roll: ';		nextPutAll: roll printString;		cr;		nextPutAll: 'Move number: ';		nextPutAll: moveNumber printString;		cr;		nextPutAll: 'PEN: '.	self basicPrintShortPenStringOn: aStream.	aStream flush.		! !!Position methodsFor: 'printing' stamp: 'BenoitStJean 1/3/2019 16:14'!basicPrintBoardOn: aStream		aStream cr;nextPutAll: '  +--+--+--+--+--+'.	aStream cr.	5 to: 1 by: -1 do: [:rowNum | 											self basicPrintRow: rowNum on: aStream.											aStream cr].	aStream nextPutAll: '  +--+--+--+--+--+'.	aStream cr.	aStream nextPutAll: '  |a |b |c |d |e |'.	aStream cr.! !!Position methodsFor: 'printing' stamp: 'BenoitStJean 1/3/2019 16:13'!printOnTranscript	self basicPrintBoardWithDetailsOn: Transcript.! !!Position methodsFor: 'printing' stamp: 'BenoitStJean 1/23/2019 14:13'!basicPrintRow: anIndex on: aStream	| start end |		start := ((anIndex - 1) * 5) + 1.	end := start + 4.		aStream nextPutAll: anIndex printString.	aStream space.	aStream nextPut: $|.		(start to: end) do: [:square | | stone |											stone := (self basicAt: square).											aStream 												nextPutAll: stone displayString ;												nextPut: $|  ]! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/10/2019 03:20'!privateSetRedStones: anArray	redStones := anArray! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/10/2019 03:20'!privateSetBlueStones: anArray	blueStones := anArray! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/31/2019 19:57'!calculateHashKey	^0! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/10/2019 03:19'!privateSetBoard: anArray	board := anArray! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/23/2019 23:39'!privateGetBlueStones	^ blueStones ! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/23/2019 23:40'!privateGetRedStones	^ redStones ! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/23/2019 23:40'!privateGetBoard	^ board! !!Position methodsFor: 'private' stamp: 'BenoitStJean 1/31/2019 19:57'!calculateHashKeyORIGINAL	| zHash |		zHash := 0.	blueStones doWithIndex: [ :bs :ix | bs notNil ifTrue: [zHash := zHash bitXor: (ZobristHash hashForStone: (BlueStone forNumber: ix) square: bs) ]].	redStones doWithIndex: [ :rs :ix | rs notNil ifTrue: [zHash := zHash bitXor: (ZobristHash hashForStone: (RedStone forNumber: ix) square: rs) ]].	(sideToMove == #BLUE) ifTrue: [ zHash := zHash bitXor: 2r1000000000000000000000000000000 ]. "bit 31"	blueStonesMoveNorth ifTrue: [ zHash := zHash bitXor: 2r1000000000000000000000000000000 ]. "bit 32"	^zHash! !!Position methodsFor: 'moves' stamp: 'BenoitStJean 1/23/2019 12:35'!makeMove: aMove	self moveFrom: aMove from to: aMove to. 	self flipSideToMove.	self incrementMoveNumber.	self flag: #comeBackLater.	hashKey := self calculateHashKey.! !!Position methodsFor: 'moves' stamp: 'BenoitStJean 1/23/2019 12:35'!undoMove: aMove	self moveFrom: aMove to to: aMove from.	self at: aMove to put: aMove captured. 	self flipSideToMove.	self decrementMoveNumber.	self flag: #comeBackLater.	hashKey := self calculateHashKey.! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 1/21/2019 20:42'!isFinal	^(self redWins or: [ self blueWins ])	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 1/21/2019 20:42'!blueWins	^(self blueWinsByElimination or: [ self blueWinsByReachingGoal ])	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 1/21/2019 20:42'!redWins	^(self redWinsByElimination or: [ self redWinsByReachingGoal ])	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 1/21/2019 20:36'!blueWinsByReachingGoal	| targetSquare |	sideToMove == #RED ifFalse: [ ^false ].	targetSquare := self targetSquareForColor: #BLUE.	^(blueStones anySatisfy: [ :square | square = targetSquare ])	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 1/21/2019 20:37'!redWinsByReachingGoal	| targetSquare |	sideToMove == #BLUE ifFalse: [ ^false ].	targetSquare := self targetSquareForColor: #RED.	^(redStones anySatisfy: [ :square | square = targetSquare ])	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 2/1/2019 15:06'!blueWinsByElimination	sideToMove == #RED ifFalse: [ ^false ].	(redStones anySatisfy: [ :stone | stone notNil ]) ifTrue: [ ^false ].	^true	! !!Position methodsFor: 'accessing-results' stamp: 'BenoitStJean 2/1/2019 15:06'!redWinsByElimination	sideToMove == #BLUE ifFalse: [ ^false ].	(blueStones anySatisfy: [ :stone | stone notNil ]) ifTrue: [ ^false ].	^true! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 3/11/2019 00:30'!onlyHasOneRedLeft	| number |	number := 0.	redStones do: [ :each | 	each notNil ifTrue: [ number := number + 1 ].									number > 1 ifTrue: [ ^false ] ].	^(number = 1)! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 3/11/2019 00:30'!onlyHasOneBlueLeft	| number |	number := 0.	blueStones do: [ :each |	each notNil ifTrue: [ number := number + 1 ].									number > 1 ifTrue: [ ^false ] ].	^(number = 1)! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 1/21/2019 16:31'!privateGetLowerStoneForRoll: anInteger	| stones |	stones := self allStonesToMove.	((anInteger - 1) >= 1)		ifTrue: [ (anInteger - 1) to: 1 by: -1 do: [:index || location target | 																			location := stones at: index.																			location notNil ifTrue: [target := board at: location].																			target isStone ifTrue: [ ^target ]]].	^nil.! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 1/21/2019 19:18'!stonesForRoll: anInteger	| stones candidates higher lower index |		stones := self allStonesToMove.	index := stones at: anInteger.	index notNil ifTrue: [ ^Array with: (board at: index) ].	candidates := OrderedCollection new.		higher := self privateGetHigherStoneForRoll: anInteger.	lower := self privateGetLowerStoneForRoll: anInteger.	higher notNil ifTrue: [candidates add: higher].	lower notNil ifTrue: [candidates add: lower].		^candidates asArray! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 1/31/2019 11:08'!stonesForRoll	^self stonesForRoll: roll! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 12/10/2018 04:34'!allStonesToMove	^(sideToMove == #BLUE)		ifTrue: [ blueStones  ]		ifFalse: [ 	(sideToMove == #RED)							ifTrue: [ redStones ]							ifFalse: [ self error: 'Should not get here!!' ]	 ]	! !!Position methodsFor: 'accessing-stones' stamp: 'BenoitStJean 1/21/2019 16:31'!privateGetHigherStoneForRoll: anInteger	| stones |	stones := self allStonesToMove.	((anInteger + 1) <= 6)		ifTrue: [ (anInteger + 1) to: stones size do: [:index |	| location target | 																				location := stones at: index.																				location notNil ifTrue: [target := board at: location].																				target isStone ifTrue: [ ^target ]]].	^nil.! !!Position methodsFor: 'initialize-release' stamp: 'BenoitStJean 11/27/2018 07:18'!initialize	board := Array new: 25.	blueStones := Array new: 6.	redStones := Array new: 6.		sideToMove := #BLUE.		blueStonesMoveNorth := true.	moveNumber := 1.! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 12/7/2018 16:01'!basicMoveFrom2: aSource to: aDestination	| stoneOnSource stoneOnDestination |	"ADD check to verify if there is a stone at <source> and if it is a stone of the side to move"	stoneOnSource := self basicAt: aSource.	(stoneOnSource color = sideToMove) ifFalse: [ self error: 'Invalid position and/or move!!' ].		stoneOnSource isStone ifTrue: [ self basicAt: aSource put: nil ].		stoneOnDestination := self basicAt: aDestination.	self basicAt: aDestination put: stoneOnSource.		self flipSideToMove.	self incrementMoveNumber.		! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 11/27/2018 07:21'!basicAt: aSquareIndex		^board at: aSquareIndex! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 11/27/2018 10:33'!at: aSquareIndexOrString put: aStoneOrNil		^self basicAt: aSquareIndexOrString asSquareIndex put: aStoneOrNil! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 12/6/2018 03:37'!moveFrom: aSource to: aDestination		self basicMoveFrom: aSource asSquareIndex to: aDestination asSquareIndex 	! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 11/27/2018 08:30'!basicAt: aSquareIndex put: aStoneOrNil	| currentStoneAtThisIndex |		currentStoneAtThisIndex := board at: aSquareIndex.		"Update the board first and after that, update the auxiliary structure so everything is in sync!!"	board at: aSquareIndex put: aStoneOrNil.		"Update the auxiliary structure and nil out the info of the stone that is about to be replaced"	currentStoneAtThisIndex isRedStone ifTrue: [ redStones at: (currentStoneAtThisIndex number) put: nil]. 	currentStoneAtThisIndex isBlueStone ifTrue: [ blueStones at: (currentStoneAtThisIndex number) put: nil]. 	"Update the auxiliary structure with the replacement"	aStoneOrNil isRedStone ifTrue: [redStones at: (aStoneOrNil number) put: aSquareIndex].	aStoneOrNil isBlueStone ifTrue: [blueStones at: (aStoneOrNil number) put: aSquareIndex].		^aStoneOrNil! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 11/27/2018 10:32'!at: aSquareIndexOrString		^board at: aSquareIndexOrString asSquareIndex! !!Position methodsFor: 'accessing-board' stamp: 'BenoitStJean 1/23/2019 23:20'!basicMoveFrom: aSource to: aDestination	| stoneOnSource stoneOnDestination |	stoneOnSource := self basicAt: aSource."	(stoneOnSource color = sideToMove) ifFalse: [ self error: 'Invalid position and/or move!!' ]."		stoneOnSource isStone ifTrue: [ self basicAt: aSource put: nil ].		stoneOnDestination := self basicAt: aDestination.	self basicAt: aDestination put: stoneOnSource.			! !!Position methodsFor: 'comparing' stamp: 'BenoitStJean 3/11/2019 01:19'!isSimilarTo: anotherPosition	"<moveNumber> and <hashKey> are not considered"	(anotherPosition class = self class) ifFalse: [ ^false ].	(sideToMove = anotherPosition sideToMove) ifFalse: [ ^false ]. 	(board = anotherPosition privateGetBoard) ifFalse: [ ^false ].	(blueStonesMoveNorth = anotherPosition blueStonesMoveNorth) ifFalse: [ ^false ]. 	(blueStones = anotherPosition privateGetBlueStones) ifFalse: [ ^false ].	(redStones = anotherPosition privateGetRedStones) ifFalse: [ ^false ].	(roll = anotherPosition roll) ifFalse: [ ^false ].		^true! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!sideToMove	^ sideToMove! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!moveNumber	^ moveNumber! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!blueStonesMoveNorth	^ blueStonesMoveNorth! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/29/2018 12:36'!roll	^roll! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!blueStonesMoveNorth: anObject	blueStonesMoveNorth := anObject! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 1/23/2019 12:34'!hashKey	^ hashKey! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/29/2018 12:36'!roll: anInteger	roll := anInteger! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 1/23/2019 12:34'!hashKey: anObject	hashKey := anObject! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!moveNumber: anObject	moveNumber := anObject! !!Position methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 07:16'!sideToMove: anObject	sideToMove := anObject! !!Position methodsFor: 'testing' stamp: 'BenoitStJean 3/11/2019 00:49'!isKillerMove: aMove	| targetSquare hasReachedGoal hasCapturedLastStone |	"Without trying this move, check if it wins by elamination or by reaching goal"	targetSquare := self targetSquareForColor: aMove sideToMove.	hasReachedGoal := (aMove to = targetSquare).	hasReachedGoal ifTrue: [ ^true ].		aMove isEnemyCapture ifFalse: [ ^false ].	hasCapturedLastStone := aMove isBlueMove										ifTrue: [ self onlyHasOneRedLeft ]										ifFalse: [ self onlyHasOneBlueLeft ].	^hasCapturedLastStone		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Position class	instanceVariableNames: ''!!Position class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/31/2019 19:41'!fromPenString: aString	| pos squares posStr theSideToMove theBlueDirection theRoll theMoveNumber endOfString isLongPenString nextDelimiterIndex |		pos := self new.	squares := #(21 22 23 24 25 16 17 18 19 20 11 12 13 14 15 6 7 8 9 10 1 2 3 4 5).	"TO ADD : validate the position of the forward slash in the string"	posStr := (aString copyFrom: 1 to: 30) reject: [ :ch | ch == $/ ].	posStr := posStr select: [:ch | #($a $b $c $d $e $f $1 $2 $3 $4 $5 $6 $0) includes: ch ].	posStr size = 25 ifFalse: [ self error: 'Invalid PEN string!!' ].	squares withIndexDo: [ :sq :ix |	| char stone |												char := posStr at: ix.												stone := Stone fromPenChar: char.												pos at: sq put: stone ].	"VALIDATE format of side to move as well, i.e. slash and B or R"											theSideToMove := (aString copyFrom: 31 to: 32) first = $B ifTrue: [#BLUE] ifFalse: [#RED].											pos sideToMove: theSideToMove.	"VALIDATE format as well, i.e. slash and N or S"											theBlueDirection := (aString copyFrom: 33 to: 34) first = $N ifTrue: [ #NORTH ] ifFalse: [ #SOUTH].	pos blueStonesMoveNorth: (theBlueDirection == #NORTH).	"VALIDATE format as well, i.e. an integer between 1 and 6 or a *"											theRoll := (aString copyFrom: 35 to: 36) first digitValue.	pos roll: theRoll.		pos hashKey: pos calculateHashKey.			endOfString := aString copyFrom: 37 to: aString size.	((endOfString includes: $;) and: [ (endOfString includes: $") ])		ifTrue: [ isLongPenString := true]		ifFalse: [ isLongPenString := false ].	isLongPenString 		ifFalse: [ 	pos moveNumber: endOfString asInteger.						^pos]		ifTrue: [ | moveNum |					nextDelimiterIndex := endOfString indexOf: $;.					moveNum := endOfString copyFrom: 1 to: (nextDelimiterIndex - 1).					pos moveNumber: moveNum asInteger.					 ].		"Add move number and optional format support"	"Later, validate that each char appears only once (except for 0)"	"(posStr reject: [ :ch | ch = $0 ]) asBag"	^pos! !!Position class methodsFor: 'instance-creation' stamp: 'BenoitStJean 11/29/2018 09:30'!atRandom	| blueStones redStones pos northSquares southSquares whoIsToMove bluesMovesTowards |		blueStones := (1 to: 6) asArray shuffled.	redStones := (1 to: 6) asArray shuffled.	pos := self new.		southSquares := #('c1' 'd1' 'e1' 'd2' 'e2' 'e3') shuffled.	northSquares := #('a3' 'a4'	'a5' 'b4' 'b5' 'c5') shuffled.			whoIsToMove := #(#RED #BLUE) atRandom.	bluesMovesTowards := #(#NORTH #SOUTH) atRandom.		bluesMovesTowards = #NORTH 		ifTrue: [ 1 to: 6 do: [ :idx |	pos at: (southSquares at: idx) put: (BlueStone forNumber: (blueStones at: idx)).												pos at: (northSquares at: idx) put: (RedStone forNumber: (redStones at: idx)).												pos blueStonesMoveNorth: true. ]] 		ifFalse: [ 1 to: 6 do: [ :idx | 	pos at: (southSquares at: idx) put: (RedStone forNumber: (redStones at: idx)).													pos at: (northSquares at: idx) put: (BlueStone forNumber: (blueStones at: idx)).													pos blueStonesMoveNorth: false]].	pos sideToMove: whoIsToMove.	^pos! !!Position class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/24/2019 17:17'!row1	^#(1 2 3 4 5)! !!Position class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/24/2019 17:17'!columnE	^#(5 10 15 20 25)! !!Position class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/24/2019 17:18'!row5	^#(21 22 23 24 25)! !!Position class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/24/2019 17:17'!columnA	^#(1 6 11 16 21)! !!Position class methodsFor: 'DOCUMENTATION' stamp: 'BenoitStJean 1/3/2019 16:45'!PEN_String_Short_Format"PEN : Portable Ewn NotationBlue stones are represented by integers [1..6]Red stones are represented by *lowecase* letters [a..f]Empty squares are represented by the number zero (0)Rows (starting from row 5 down to 1, from left to right) are separated by a slash (aka forward slash) /Rows are described from left to right, rows are always 5 characters long.Side to move is either (B)lue or (R)ed in capital lettersBlue stones direction is either (N)orth or (S)outh in capital lettersDie roll is an integer [1..6] OR an asterisk (*) when unknownMove number is an integer OR an asterisk (*) when unknown[row5]/[row4]/[row3]/[row2]/[row1]/[side to move]/[blue direction]/[die roll]/[move number]example:afc00/eb000/d0004/00015/00326/B/N/2/1  +--+--+--+--+--+5 |R1|R6|R3|..|..|4 |R5|R2|..|..|..|3 |R4|..|..|..|B4|2 |..|..|..|B1|B5|1 |..|..|B3|B2|B6|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: NORTHRoll: 2Move number: 1"! !!Position class methodsFor: 'helpers-squares-ok' stamp: 'BenoitStJean 12/10/2018 06:24'!stringForSquare: anInteger	| column row rowChar columnChar |		(anInteger between: 1 and: 25) ifFalse: [ self error: 'Invalid square!!' ].	row := ((anInteger - 1) // 5) + 1.	column := ((anInteger - 1) \\ 5) + 1.	rowChar := '12345' at: row.	columnChar := 'abcdef' at: column.	^String with: columnChar with: rowChar.! !!Position class methodsFor: 'helpers-squares-ok' stamp: 'BenoitStJean 11/15/2018 05:25'!squareForString: aString	| column row square |		aString size = 2 ifFalse: [ self error: 'Invalid square!!' ].	('abcde' includes: aString first) ifFalse: [ self error: 'Invalid square column!!' ].	('12345' includes: aString second) ifFalse: [ self error: 'Invalid square row!!' ].		row := (aString at: 2) digitValue.	column := (aString at: 1) codePoint - 96.		square := (5 * (row - 1)) + column.	^square! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 23:23'!example12String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|..|..|..|2 |..|..|..|..|B6|1 |..|..|..|B1|R2|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: SOUTHRoll: 3Move number: 20PEN: 00000/00000/00000/00006/0001b/B/S/3/20"	^'00000/00000/00000/00006/0001b/B/S/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 16:00'!example04String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|..|B2|..|2 |..|..|..|R1|R6|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 3Move number: 20PEN: 00000/00000/00020/000af/00000/R/N/3/20"	^'00000/00000/00020/000af/00000/R/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 22:11'!example09String"  +--+--+--+--+--+5 |R2|B6|..|..|..|4 |B1|..|..|..|..|3 |..|..|..|..|..|2 |..|..|..|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: NORTHRoll: 3Move number: 20PEN: b6000/10000/00000/00000/00000/B/N/3/20"	^'b6000/10000/00000/00000/00000/B/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/20/2019 07:27'!example01bString"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|R1|R6|..|..|3 |..|..|B2|..|..|2 |..|..|..|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 3Move number: 19PEN: 00000/0af00/00200/00000/00000/R/N/3/19"	^'00000/0af00/00200/00000/00000/R/N/3/19;b4xc3, c4xc3;"Test position #1"'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 15:10'!example01String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|R1|R6|..|..|3 |..|..|B2|..|..|2 |..|..|..|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 3Move number: 19PEN: 00000/0af00/00200/00000/00000/R/N/3/19"	^'00000/0af00/00200/00000/00000/R/N/3/19'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 15:15'!example02String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|B2|..|..|2 |..|..|..|R1|R6|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 3Move number: 20PEN: 00000/00000/00200/000af/00000/R/N/3/20"	^'00000/00000/00200/000af/00000/R/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 20:46'!example07String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|R2|B6|..|2 |..|..|B1|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: NORTHRoll: 3Move number: 20PEN: 00000/00000/00b60/00100/00000/B/N/3/20"	^'00000/00000/00b60/00100/00000/B/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 23:17'!example11String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|R5|..|..|..|2 |..|..|..|..|B6|1 |..|..|..|B1|R2|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: SOUTHRoll: 3Move number: 20PEN: 00000/00000/0e000/00006/0001b/B/S/3/20"	^'00000/00000/0e000/00006/0001b/B/S/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 16:04'!example05String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |R1|R6|B4|..|..|3 |..|..|..|B2|..|2 |..|..|..|B1|B6|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: SOUTHRoll: 3Move number: 20PEN: 00000/af400/00020/00016/00000/R/S/3/20"	^'00000/af400/00020/00016/00000/R/S/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/31/2019 19:45'!example23String"  +--+--+--+--+--+5 |B2|B4|B1|..|..|4 |B3|B6|..|..|..|3 |B5|..|..|..|R3|2 |..|..|..|R5|R1|1 |..|..|R6|R2|R4|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: SOUTHRoll: 2Move number: 1PEN: 24100/36000/5000c/000ea/00fbd/R/S/2/1	"	^'24100/36000/5000c/000ea/00fbd/R/S/2/1'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/31/2019 19:45'!example22String"  +--+--+--+--+--+5 |R2|R4|R1|..|..|4 |R3|R6|..|..|..|3 |R5|..|..|..|B3|2 |..|..|..|B5|B1|1 |..|..|B6|B2|B4|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: NORTHRoll: 5Move number: 1PEN: bda00/cf000/e0003/00051/00624/B/N/5/1"	^'bda00/cf000/e0003/00051/00624/B/N/5/1'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/31/2019 19:45'!example21String"  +--+--+--+--+--+5 |R2|R4|R1|..|..|4 |R3|R6|..|..|..|3 |R5|..|..|..|B3|2 |..|..|..|B5|B1|1 |..|..|B6|B2|B4|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 4Move number: 1PEN: bda00/cf000/e0003/00051/00624/R/N/4/1"	^'bda00/cf000/e0003/00051/00624/R/N/4/1'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 20:41'!example06String"  +--+--+--+--+--+5 |B3|..|..|..|..|4 |R1|R6|B4|..|..|3 |..|..|..|B2|..|2 |..|..|..|B1|B6|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: SOUTHRoll: 3Move number: 20PEN: 30000/af400/00020/00016/00000/R/S/3/20"	^'30000/af400/00020/00016/00000/R/S/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/31/2019 19:45'!example24String"  +--+--+--+--+--+5 |B2|B4|B1|..|..|4 |B3|B6|..|..|..|3 |B5|..|..|..|R3|2 |..|..|..|R5|R1|1 |..|..|R6|R2|R4|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: SOUTHRoll: 3Move number: 1PEN: 24100/36000/5000c/000ea/00fbd/B/S/3/1"	^'24100/36000/5000c/000ea/00fbd/B/S/3/1'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 21:18'!example08String"  +--+--+--+--+--+5 |..|B6|..|..|..|4 |B1|..|..|..|..|3 |..|..|R2|..|..|2 |..|..|..|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: NORTHRoll: 3Move number: 20PEN: 06000/10000/00b00/00000/00000/B/N/3/20"	^'06000/10000/00b00/00000/00000/B/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 15:46'!example03String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|..|..|..|2 |..|..|..|R1|R6|1 |..|..|..|..|B2|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: REDBlue is moving: NORTHRoll: 3Move number: 20PEN: 00000/00000/00000/000af/00002/R/N/3/20"	^'00000/00000/00000/000af/00002/R/N/3/20'! !!Position class methodsFor: 'examples' stamp: 'BenoitStJean 1/19/2019 23:12'!example10String"  +--+--+--+--+--+5 |..|..|..|..|..|4 |..|..|..|..|..|3 |..|..|B6|..|..|2 |..|B1|R2|..|..|1 |..|..|..|..|..|  +--+--+--+--+--+  |a |b |c |d |e |Side to move: BLUEBlue is moving: SOUTHRoll: 3Move number: 20PEN: 00000/00000/00600/01b00/00000/B/S/3/20"	^'00000/00000/00600/01b00/00000/B/S/3/20'! !!Position class methodsFor: 'helpers-stones-ok' stamp: 'BenoitStJean 11/15/2018 05:55'!isSouthStone: anInteger		anInteger isNil ifTrue: [ ^false ].	((anInteger between: 1 and: 6) or: [(anInteger between: -6 and: -1)]) ifFalse: [ self error: 'Invalid stone!!' ]. 		^(anInteger between: 1 and: 6) ! !!Position class methodsFor: 'helpers-stones-ok' stamp: 'BenoitStJean 11/15/2018 07:34'!longStringForStone: anIntegerOrNil	"South [S1, S2, ..S6], north [N1, N2, ..N6], empty square is represented by '..' "	anIntegerOrNil isNil ifTrue: [ ^'..' ].	(anIntegerOrNil between: 1 and: 6) ifTrue: [ ^('S', anIntegerOrNil printString) ].	(anIntegerOrNil between: -6 and: -1) ifTrue: [ ^('N', anIntegerOrNil abs printString) ].			self error: 'Invalid integer for stone!!' ! !!Position class methodsFor: 'helpers-stones-ok' stamp: 'BenoitStJean 11/15/2018 06:35'!stoneForChar: aCharacter	"South [1..6], north [a..f], empty square can either be represented by $0 or $. "	| stoneChar  |		stoneChar := '123456' indexOf: aCharacter.	(stoneChar ~= 0) ifTrue: [ ^stoneChar ].		stoneChar := 'abcdef' indexOf: aCharacter.	(stoneChar ~= 0) ifTrue: [ ^stoneChar negated ].		(aCharacter == $0) ifTrue: [ ^nil ].	(aCharacter == $.) ifTrue: [ ^nil ].			self error: 'Invalid character for stone!!' ! !!Position class methodsFor: 'helpers-stones-ok' stamp: 'BenoitStJean 11/15/2018 05:50'!isNorthStone: anInteger		anInteger isNil ifTrue: [ ^false ].	((anInteger between: 1 and: 6) or: [(anInteger between: -6 and: -1)]) ifFalse: [ self error: 'Invalid stone!!' ]. 		^(anInteger between: -6 and: -1) ! !!Position class methodsFor: 'helpers-stones-ok' stamp: 'BenoitStJean 11/15/2018 06:42'!integerAsNorthStone: anInteger	(anInteger between: 1 and: 6) ifTrue: [ ^anInteger negated ].	^self error: 'Invalid stone integer'.! !Object subclass: #Referee	instanceVariableNames: 'player1 player2 timeControl1 timeControl2 statistics'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!Referee methodsFor: 'playing-game' stamp: 'BenoitStJean 1/21/2019 14:46'!bluePlayer: aBluePlayer moving: aDirectionSymbol andRedPlayer: aRedPlayer withFirstMoveBy: aColorSymbol! !!Referee methodsFor: 'playing-game' stamp: 'BenoitStJean 1/21/2019 14:51'!newGameWithBluePlayer: aBluePlayer moving: aDirectionSymbol andRedPlayer: aRedPlayer withFirstMoveBy: aColorSymbol! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!statistics	^ statistics! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!statistics: anObject	statistics := anObject! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!player1: anObject	player1 := anObject! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!player2	^ player2! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!timeControl2: anObject	timeControl2 := anObject! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!timeControl1: anObject	timeControl1 := anObject! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!timeControl2	^ timeControl2! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!player1	^ player1! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!timeControl1	^ timeControl1! !!Referee methodsFor: 'accessing' stamp: 'BenoitStJean 1/21/2019 15:04'!player2: anObject	player2 := anObject! !!Referee methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 1/21/2019 15:02'!nextRoll	^6 atRandom! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Referee class	instanceVariableNames: ''!!Referee class methodsFor: 'creation-games' stamp: 'BenoitStJean 1/21/2019 15:07'!newGameWithBluePlayer: aBluePlayer moving: aDirectionSymbol andRedPlayer: aRedPlayer withFirstMoveBy: aColorSymbol	| ref pos |		ref := self basicNew.	pos := Position atRandom.	pos sideToMove: aColorSymbol.	pos blueStonesMove: aDirectionSymbol.! !!Referee class methodsFor: 'instance creation' stamp: 'BenoitStJean 1/21/2019 14:52'!newMatchWithBluePlayer: aBluePlayer andRedPlayer: aRedPlayer numberOfGames: anInteger! !!Referee class methodsFor: 'instance creation' stamp: 'BenoitStJean 1/21/2019 14:53'!newMatchWithBluePlayer: aBluePlayer andRedPlayer: aRedPlayer numberOfGames: anInteger startingPosition: aPENString! !Object subclass: #Stone	instanceVariableNames: 'number'	classVariableNames: 'Stones'	poolDictionaries: ''	category: 'Caerus-Core'!!Stone methodsFor: 'printing' stamp: 'BenoitStJean 11/27/2018 08:36'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self number printString;		nextPut: $).! !!Stone methodsFor: 'testing' stamp: 'BenoitStJean 11/26/2018 00:14'!isStone	^true	! !!Stone methodsFor: 'testing' stamp: 'BenoitStJean 1/3/2019 16:12'!isBlueStone	^false	! !!Stone methodsFor: 'testing' stamp: 'BenoitStJean 1/3/2019 16:12'!isRedStone	^false	! !!Stone methodsFor: 'accessing' stamp: 'BenoitStJean 11/25/2018 15:48'!number	^ number! !!Stone methodsFor: 'private' stamp: 'BenoitStJean 11/26/2018 15:38'!penAlphabet	^self class penAlphabet! !!Stone methodsFor: 'private' stamp: 'BenoitStJean 11/26/2018 00:30'!setNumber: anInteger	number := anInteger! !!Stone methodsFor: 'private' stamp: 'BenoitStJean 1/3/2019 08:15'!zobristIndex	^self shouldNotImplement ! !!Stone methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 3/11/2019 01:19'!= anotherStone	(self class == anotherStone class) ifFalse: [ ^false].	(self color == anotherStone color) ifFalse: [ ^false].	(self number == anotherStone number) ifFalse: [ ^false].		^true! !!Stone methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/23/2019 15:10'!color	self shouldNotImplement ! !!Stone methodsFor: 'accessing-derived' stamp: 'BenoitStJean 11/26/2018 15:38'!penString	^self penAlphabet at: number! !!Stone methodsFor: 'accessing-derived' stamp: 'BenoitStJean 11/27/2018 07:03'!penCharacter	^self penString first! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Stone class	instanceVariableNames: ''!!Stone class methodsFor: 'initialize-release' stamp: 'BenoitStJean 11/27/2018 06:56'!reset	Stones := nil! !!Stone class methodsFor: 'initialize-release' stamp: 'BenoitStJean 11/27/2018 06:59'!initialize	"self initialize"	Stones := Array new: 12.		1 to: 6 do: [ :idx |	Stones at: idx put: ((BlueStone basicNew) setNumber: idx)].	1 to: 6 do: [ :idx |	Stones at: (idx + 6) put: ((RedStone basicNew) setNumber: idx)].			! !!Stone class methodsFor: 'instance-creation' stamp: 'BenoitStJean 11/27/2018 07:01'!fromPenString: aString		aString isEmptyPenString ifTrue: [ ^nil ].		aString isRedPenString ifTrue: [ ^RedStone forNumber: (RedStone penAlphabet indexOf: aString) ].	aString isBluePenString ifTrue: [ ^BlueStone forNumber: (BlueStone penAlphabet indexOf: aString) ].			self error: 'Invalid argument <aString>!!'! !!Stone class methodsFor: 'instance-creation' stamp: 'BenoitStJean 11/27/2018 07:00'!fromPenChar: aCharacter		^self fromPenString: (String with: aCharacter)! !!Stone class methodsFor: 'accessing' stamp: 'BenoitStJean 11/27/2018 06:18'!stones	Stones isNil ifTrue: [ self initialize ].	^Stones! !!Stone class methodsFor: 'should not implement' stamp: 'BenoitStJean 11/26/2018 02:40'!forNumber: anInteger	self shouldBeImplemented ! !!Stone class methodsFor: 'should not implement' stamp: 'BenoitStJean 11/26/2018 02:39'!new: anObject	self shouldBeImplemented ! !!Stone class methodsFor: 'should not implement' stamp: 'BenoitStJean 11/26/2018 02:39'!new	self shouldBeImplemented ! !Stone subclass: #BlueStone	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!BlueStone methodsFor: 'accessing-derived' stamp: 'BenoitStJean 12/31/2018 08:59'!color	^#BLUE! !!BlueStone methodsFor: 'private' stamp: 'BenoitStJean 1/3/2019 08:16'!zobristIndex	^number! !!BlueStone methodsFor: 'testing' stamp: 'BenoitStJean 11/26/2018 00:14'!isBlueStone	^true! !!BlueStone methodsFor: 'displaying' stamp: 'BenoitStJean 1/23/2019 14:14'!displayString	^#('B1' 'B2' 'B3' 'B4' 'B5' 'B6') at: number! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BlueStone class	instanceVariableNames: ''!!BlueStone class methodsFor: 'instance-creation' stamp: 'BenoitStJean 11/27/2018 06:55'!forNumber: anInteger	^self stones at: anInteger.! !!BlueStone class methodsFor: 'constants' stamp: 'BenoitStJean 11/26/2018 15:06'!penAlphabet	^#('1' '2' '3' '4' '5' '6') ! !Stone subclass: #RedStone	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Core'!!RedStone methodsFor: 'private' stamp: 'BenoitStJean 1/3/2019 08:16'!zobristIndex	^(number + 6)! !!RedStone methodsFor: 'accessing-derived' stamp: 'BenoitStJean 12/31/2018 08:59'!color	^#RED! !!RedStone methodsFor: 'displaying' stamp: 'BenoitStJean 1/23/2019 14:15'!displayString	^#('R1' 'R2' 'R3' 'R4' 'R5' 'R6') at: number! !!RedStone methodsFor: 'testing' stamp: 'BenoitStJean 11/26/2018 00:15'!isRedStone	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RedStone class	instanceVariableNames: ''!!RedStone class methodsFor: 'instance-creation' stamp: 'BenoitStJean 11/27/2018 06:55'!forNumber: anInteger	^self stones at: (anInteger + 6).! !!RedStone class methodsFor: 'constants' stamp: 'BenoitStJean 11/26/2018 15:06'!penAlphabet	^#('a' 'b' 'c' 'd' 'e' 'f') ! !Stone initialize!Object subclass: #SimulatedGameStats	instanceVariableNames: 'move redWins blueWins score'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Statistics'!!SimulatedGameStats methodsFor: 'accessing-derived' stamp: 'BenoitStJean 2/1/2019 11:20'!addRedWin	redWins := redWins + 1.! !!SimulatedGameStats methodsFor: 'accessing-derived' stamp: 'BenoitStJean 2/1/2019 11:31'!games	^(blueWins + redWins) ! !!SimulatedGameStats methodsFor: 'accessing-derived' stamp: 'BenoitStJean 2/1/2019 11:20'!addBlueWin	blueWins := blueWins + 1.! !!SimulatedGameStats methodsFor: 'initialize-release' stamp: 'BenoitStJean 2/1/2019 12:54'!initialize	redWins := 0.	blueWins := 0.	score := 0.0.	! !!SimulatedGameStats methodsFor: 'accessing' stamp: 'BenoitStJean 2/1/2019 12:55'!score	"CAVEAT : the score (percentage of wins) is *ALWAYS* calculated for the #BLUE side !!"	(self games = 0) 		ifTrue: [ score := 0.0 ]		ifFalse: [ score := (blueWins / (self games)) asFloat ].	^score! !!SimulatedGameStats methodsFor: 'accessing' stamp: 'BenoitStJean 2/1/2019 11:19'!redWins	^ redWins! !!SimulatedGameStats methodsFor: 'accessing' stamp: 'BenoitStJean 2/1/2019 11:19'!blueWins	^ blueWins! !!SimulatedGameStats methodsFor: 'accessing' stamp: 'BenoitStJean 2/1/2019 11:19'!move: anObject	move := anObject! !!SimulatedGameStats methodsFor: 'accessing' stamp: 'BenoitStJean 2/1/2019 11:19'!move	^ move! !!SimulatedGameStats methodsFor: 'printing' stamp: 'BenoitStJean 2/1/2019 12:40'!printOn: aStream	aStream nextPutAll: self class printString.	aStream nextPutAll: ' ('.	move printOn: aStream.	aStream nextPutAll: ' b: ', blueWins printString.	aStream nextPutAll: ' r: ', redWins printString.		aStream nextPutAll: ' score: ', (self score printShowingDecimalPlaces: 4).	aStream nextPutAll: ')'.! !PackageManifest subclass: #ManifestCaerus	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus'!!ManifestCaerus commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCaerus class	instanceVariableNames: ''!!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 1/22/2019 20:07'!ruleClassNotReferencedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#HumanPlayer)) #'2019-01-21T22:14:20.820553-05:00') #(#(#RGClassDefinition #(#SuddenDeathControl)) #'2019-01-21T22:14:20.821553-05:00') #(#(#RGClassDefinition #(#CleverRandomPlayer)) #'2019-01-21T22:14:20.823553-05:00') #(#(#RGClassDefinition #(#TimePerMoveWithIncrementControl)) #'2019-01-21T22:14:20.822553-05:00') #(#(#RGClassDefinition #(#CleverMonteCarloPlayer)) #'2019-01-21T22:14:20.824553-05:00') #(#(#RGClassDefinition #(#SimulatedGamesControl)) #'2019-01-21T22:14:20.824553-05:00') #(#(#RGClassDefinition #(#SearchDepthControl)) #'2019-01-21T22:14:20.821553-05:00') #(#(#RGClassDefinition #(#MovesPerTimeControl)) #'2019-01-21T22:14:20.821553-05:00') #(#(#RGClassDefinition #(#HashTable)) #'2019-01-22T20:07:29.338553-05:00') #(#(#RGClassDefinition #(#Referee)) #'2019-01-22T20:07:29.306553-05:00') )! !!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 1/23/2019 15:15'!ruleCascadedNextPutAllsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#ZobristHashTests #testZobristHashingPerformance #false)) #'2019-01-23T15:15:55.631553-05:00') )! !!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 1/23/2019 15:15'!ruleOverridesSpecialMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Position #basicAt: #false)) #'2019-01-23T15:15:55.688553-05:00') #(#(#RGMethodDefinition #(#Position #basicAt:put: #false)) #'2019-01-23T15:15:55.688553-05:00') )! !!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 1/23/2019 15:15'!ruleLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#ExtensionsTests #testIntegerExtensions #false)) #'2019-01-23T15:15:55.736553-05:00') #(#(#RGMethodDefinition #(#PositionTests #testSquareForString #false)) #'2019-01-23T15:15:55.736553-05:00') #(#(#RGMethodDefinition #(#ExtensionsTests #testStringExtensions #false)) #'2019-01-23T15:15:55.736553-05:00') )! !!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 1/23/2019 15:15'!ruleInconsistentMethodClassificationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Position #initialize #false)) #'2019-01-23T12:51:57.051553-05:00') #(#(#RGMethodDefinition #(#CaerusPlayer #initialize #false)) #'2019-01-23T12:51:57.051553-05:00') #(#(#RGMethodDefinition #(#MoveGenerator #initialize #false)) #'2019-01-23T12:51:57.052553-05:00') #(#(#RGMethodDefinition #(#Position #basicAt:put: #false)) #'2019-01-23T15:15:55.763553-05:00') #(#(#RGMethodDefinition #(#Position #at:put: #false)) #'2019-01-23T15:15:55.763553-05:00') #(#(#RGMethodDefinition #(#Position #at: #false)) #'2019-01-23T15:15:55.762553-05:00') #(#(#RGMethodDefinition #(#Position #basicAt: #false)) #'2019-01-23T15:15:55.762553-05:00') )! !!ManifestCaerus class methodsFor: 'code-critics' stamp: 'BenoitStJean 3/11/2019 00:31'!ruleRBDetectContainsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Position #onlyHasOneBlueLeft #false)) #'2019-03-11T00:31:11.906342-04:00') #(#(#RGMethodDefinition #(#Position #onlyHasOneRedLeft #false)) #'2019-03-11T00:31:17.035342-04:00') )! !TestCase subclass: #AbstractPlayerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!TestCase subclass: #ExtensionsTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!!ExtensionsTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 14:18'!testUndefinedObjectExtensions		self assert: nil displayString equals: '..'.	self assert: nil isBlueStone equals: false.	self assert: nil isRedStone equals: false.	self assert: nil isStone equals: false.	self assert: nil penCharacter equals: $0.	self assert: nil penString equals: '0'.	! !!ExtensionsTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 12:47'!testCharacterExtensions	| redChars blueChars invalidChars |		blueChars := '123456'.	redChars := 'abcdef'.	invalidChars := '780pqr%'.		blueChars do: [ :ch | self assert: ch isBluePenChar equals: true ].	blueChars do: [ :ch | self assert: ch isRedPenChar equals: false ].	redChars do: [ :ch | self assert: ch isBluePenChar equals: false ].	redChars do: [ :ch | self assert: ch isRedPenChar equals: true ].		invalidChars do: [ :ch | self assert: ch isBluePenChar equals: false.									self assert: ch isRedPenChar equals: false].									self assert: $0 isEmptyPenChar equals: true.! !!ExtensionsTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 14:09'!testSymbolExtensions	self assert: #RED oppositeColor equals: #BLUE.	self assert: #BLUE oppositeColor equals: #RED.		self should: [#whatever oppositeColor] raise: Error. 	self should: [#red oppositeColor] raise: Error. 	self should: [#Blue oppositeColor] raise: Error. 		! !!ExtensionsTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 14:06'!testStringExtensions	self assert: '0' isEmptyPenString equals: true.	'126456' do: [:char | self assert: (char asString isBluePenString) equals: true].	'abcdef' do: [:char | self assert: (char asString isRedPenString) equals: true].	self assert: 'a1' asSquareIndex equals: 1.	self assert: 'e1' asSquareIndex equals: 5.	self assert: 'a5' asSquareIndex equals: 21.	self assert: 'e5' asSquareIndex equals: 25.	self assert: 'b2' asSquareIndex equals: 7.		self should: ['f2' asSquareIndex] raise: Error. 	self should: ['a6' asSquareIndex] raise: Error. 	self should: ['e7' asSquareIndex] raise: Error. 	self should: ['a0' asSquareIndex] raise: Error. 	self should: ['zz' asSquareIndex] raise: Error. ! !!ExtensionsTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 13:59'!testIntegerExtensions	self assert: 1 asSquareIndex equals: 1.	self assert: 10 asSquareIndex equals: 10.	self assert: 17 asSquareIndex equals: 17.	self assert: 24 asSquareIndex equals: 24.	self assert: 25 asSquareIndex equals: 25.	 	self should: [0 asSquareIndex] raise: Error. 	self should: [26 asSquareIndex] raise: Error. 	self should: [-3 asSquareIndex] raise: Error. 		self assert: 1 asSquare equals: 'a1'.	self assert: 5 asSquare equals: 'e1'.	self assert: 21 asSquare equals: 'a5'.	self assert: 25 asSquare equals: 'e5'.	self assert: 7 asSquare equals: 'b2'.		self should: [0 asSquare] raise: Error. 	self should: [26 asSquare] raise: Error. 	self should: [-1 asSquare] raise: Error. 		! !TestCase subclass: #MoveGeneratorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!TestCase subclass: #MoveTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!TestCase subclass: #PlayerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!!PlayerTests methodsFor: 'running' stamp: 'BenoitStJean 1/21/2019 15:54'!setUp! !!PlayerTests methodsFor: 'tests' stamp: 'BenoitStJean 3/11/2019 02:04'!testNormalVersusCleverMonteCarlo	| pos pla1 pla2 i t1 t2 |		i := 0.	pos := Position fromPenString: Position example01String.	pla1 := MonteCarloPlayer new.	pla1 setPosition: pos.	pos basicPrintBoardWithDetailsOn: Transcript.	Transcript cr.	t1 := Time millisecondsToRun: [pla1 getNextMove].		pos := Position fromPenString: Position example21String.	pla2 := CleverMonteCarloPlayer new.	pla2 setPosition: pos.	pos basicPrintBoardWithDetailsOn: Transcript.	Transcript cr.	t2 := Time millisecondsToRun: [pla2 getNextMove].		self assert: (t1 > t2).	(Array with: t1 with: t2) inspect.! !!PlayerTests methodsFor: 'tests' stamp: 'BenoitStJean 1/31/2019 12:22'!testPositionMonteCarloPlayer01	| pos pla i |		1=1 ifTrue: [ ^self].	i := 0.	pos := Position fromPenString: Position example01String.	pla := MonteCarloPlayer new.	pla setPosition: pos. 	pos basicPrintBoardWithDetailsOn: Transcript.	Transcript cr.	pla getNextMove! !!PlayerTests methodsFor: 'tests' stamp: 'BenoitStJean 1/31/2019 19:46'!testPositionMonteCarloPlayer01b	| pos pla i t |		i := 0.	pos := Position fromPenString: Position example01String.	pla := MonteCarloPlayer new.	pla setPosition: pos. 	pos basicPrintBoardWithDetailsOn: Transcript.	Transcript cr.	t := Time millisecondsToRun: [pla getNextMove].! !!PlayerTests methodsFor: 'tests' stamp: 'BenoitStJean 3/11/2019 02:03'!testRegressionPerformance2	| arr players t |	"	Original version, 0.01 : 100000 simulations in 493649 milliseconds.	v0.02 with hashKey calculations removed : 100000 simulations in 231880 milliseconds.	v0.03 with #allAvailableMoves replaced by a random roll + a selection from the moves of fewer stones : 100000 simulations in 224853 milliseconds	v0.04 First version to play on LittleGolem set to 2M games simulated!!	v0.05 Fixed copy bug & optimized elimination detection : 100000 simulations in 26697 milliseconds.	"	arr := Array new: 16.	arr at: 1 put: (Position fromPenString: Position example01String).	arr at: 2 put: (Position fromPenString: Position example02String).	arr at: 3 put: (Position fromPenString: Position example03String).	arr at: 4 put: (Position fromPenString: Position example04String).	arr at: 5 put: (Position fromPenString: Position example05String).	arr at: 6 put: (Position fromPenString: Position example06String).	arr at: 7 put: (Position fromPenString: Position example07String).	arr at: 8 put: (Position fromPenString: Position example08String).	arr at: 9 put: (Position fromPenString: Position example09String).	arr at: 10 put: (Position fromPenString: Position example10String).	arr at: 11 put: (Position fromPenString: Position example11String).	arr at: 12 put: (Position fromPenString: Position example12String).		arr at: 13 put: (Position fromPenString: Position example21String).	arr at: 14 put: (Position fromPenString: Position example22String).	arr at: 15 put: (Position fromPenString: Position example23String).	arr at: 16 put: (Position fromPenString: Position example24String).	players := Array new: 24.	players at: 1 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 1)).	players at: 2 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 2)).	players at: 3 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 3)).	players at: 4 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 4)).	players at: 5 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 5)).	players at: 6 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 6)).	players at: 7 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 7)).	players at: 8 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 8)).	players at: 9 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 9)).	players at: 10 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 10)).	players at: 11 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 11)).	players at: 12 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 12)).	players at: 13 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 13)).	players at: 14 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 14)).	players at: 15 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 15)).	players at: 16 put: ((CleverMonteCarloPlayer new) setPosition: (arr at: 16)).	 	"pos basicPrintBoardWithDetailsOn: Transcript."	Transcript cr.	t := Time millisecondsToRun: [	1 to: 16 do: [:ix | (players at: ix) getNextMove]].	t inspect! !!PlayerTests methodsFor: 'tests' stamp: 'BenoitStJean 3/11/2019 02:03'!testRegressionPerformance	| arr players t |	"	Original version, 0.01 : 100000 simulations in 493649 milliseconds.	v0.02 with hashKey calculations removed : 100000 simulations in 231880 milliseconds.	v0.03 with #allAvailableMoves replaced by a random roll + a selection from the moves of fewer stones : 100000 simulations in 224853 milliseconds	v0.04 First version to play on LittleGolem set to 2M games simulated!!	v0.05 Fixed copy bug & optimized elimination detection : 100000 simulations in 26697 milliseconds.	"	1=1 ifTrue: [ ^self ].	arr := Array new: 16.	arr at: 1 put: (Position fromPenString: Position example01String).	arr at: 2 put: (Position fromPenString: Position example02String).	arr at: 3 put: (Position fromPenString: Position example03String).	arr at: 4 put: (Position fromPenString: Position example04String).	arr at: 5 put: (Position fromPenString: Position example05String).	arr at: 6 put: (Position fromPenString: Position example06String).	arr at: 7 put: (Position fromPenString: Position example07String).	arr at: 8 put: (Position fromPenString: Position example08String).	arr at: 9 put: (Position fromPenString: Position example09String).	arr at: 10 put: (Position fromPenString: Position example10String).	arr at: 11 put: (Position fromPenString: Position example11String).	arr at: 12 put: (Position fromPenString: Position example12String).		arr at: 13 put: (Position fromPenString: Position example21String).	arr at: 14 put: (Position fromPenString: Position example22String).	arr at: 15 put: (Position fromPenString: Position example23String).	arr at: 16 put: (Position fromPenString: Position example24String).	players := Array new: 24.	players at: 1 put: ((MonteCarloPlayer new) setPosition: (arr at: 1)).	players at: 2 put: ((MonteCarloPlayer new) setPosition: (arr at: 2)).	players at: 3 put: ((MonteCarloPlayer new) setPosition: (arr at: 3)).	players at: 4 put: ((MonteCarloPlayer new) setPosition: (arr at: 4)).	players at: 5 put: ((MonteCarloPlayer new) setPosition: (arr at: 5)).	players at: 6 put: ((MonteCarloPlayer new) setPosition: (arr at: 6)).	players at: 7 put: ((MonteCarloPlayer new) setPosition: (arr at: 7)).	players at: 8 put: ((MonteCarloPlayer new) setPosition: (arr at: 8)).	players at: 9 put: ((MonteCarloPlayer new) setPosition: (arr at: 9)).	players at: 10 put: ((MonteCarloPlayer new) setPosition: (arr at: 10)).	players at: 11 put: ((MonteCarloPlayer new) setPosition: (arr at: 11)).	players at: 12 put: ((MonteCarloPlayer new) setPosition: (arr at: 12)).	players at: 13 put: ((MonteCarloPlayer new) setPosition: (arr at: 13)).	players at: 14 put: ((MonteCarloPlayer new) setPosition: (arr at: 14)).	players at: 15 put: ((MonteCarloPlayer new) setPosition: (arr at: 15)).	players at: 16 put: ((MonteCarloPlayer new) setPosition: (arr at: 16)).	 	"pos basicPrintBoardWithDetailsOn: Transcript."	Transcript cr.	t := Time millisecondsToRun: [	1 to: 16 do: [:ix | (players at: ix) getNextMove]].	t inspect! !TestCase subclass: #PositionTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!!PositionTests methodsFor: 'tests' stamp: 'BenoitStJean 1/24/2019 00:42'!testIsNorthStone 	(-6 to: -1) do: [ :num | self assert: (Position isNorthStone: num) ].	(1 to: 6) do: [ :num | self deny: (Position isNorthStone: num) ].		self deny: (Position isNorthStone: nil). 		self should: [Position isNorthStone: 2112] raise: Error. 	self should: [Position isNorthStone: -2112] raise: Error. 	self should: [Position isNorthStone: 0] raise: Error. ! !!PositionTests methodsFor: 'tests' stamp: 'BenoitStJean 3/11/2019 01:17'!testCopy	| posOriginal posCopy mv mg | 	posOriginal := Position fromPenString: Position example21String.	posCopy := posOriginal copy.	"move from a5 to b4"	mg := MoveGenerator on: posOriginal.	mv := (mg movesForRoll: 2) detect: [ :mov | mov to = 17 ].	posOriginal makeMove: mv.	self deny: (posOriginal = posCopy).	posOriginal undoMove: mv.	self assert: (posOriginal isSimilarTo: posCopy).	! !!PositionTests methodsFor: 'tests' stamp: 'BenoitStJean 11/27/2018 11:34'!testStoneForChar 	'123456' doWithIndex: [ :c :idx | self assert: (Position stoneForChar: c) equals: idx ]. 	'abcdef' doWithIndex: [ :c :idx | self assert: (Position stoneForChar: c) equals: idx negated ].	self assert: (Position stoneForChar: $0) equals: nil.	self assert: (Position stoneForChar: $.) equals: nil.	self should: [Position stoneForChar: $z] raise: Error. 	self should: [Position stoneForChar: nil] raise: Error. ! !!PositionTests methodsFor: 'tests' stamp: 'BenoitStJean 1/24/2019 00:43'!testIsSouthStone 	(-6 to: -1) do: [ :num | self deny: (Position isSouthStone: num) ].	(1 to: 6) do: [ :num | self assert: (Position isSouthStone: num) ].		self deny: (Position isSouthStone: nil). 		self should: [Position isSouthStone: 2112] raise: Error. 	self should: [Position isSouthStone: -2112] raise: Error. 	self should: [Position isSouthStone: 0] raise: Error. ! !!PositionTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 13:50'!testSquareForString	self assert: (Position squareForString: 'a1') equals: 1. 	self assert: (Position squareForString: 'e1') equals: 5. 	self assert: (Position squareForString: 'a5') equals: 21. 	self assert: (Position squareForString: 'e5') equals: 25. 	self assert: (Position squareForString: 'b2') equals: 7. 	self assert: (Position squareForString: 'c4') equals: 18. 	self assert: (Position squareForString: 'd2') equals: 9. 	self assert: (Position squareForString: 'd4') equals: 19.		self should: [(Position squareForString: 'g4')] raise: Error.	self should: [(Position squareForString: 'a7')] raise: Error.	self should: [(Position squareForString: '3a')] raise: Error.	self should: [(Position squareForString: 'xyz')] raise: Error.	self should: [(Position squareForString: '33')] raise: Error.	self should: [(Position squareForString: '3')] raise: Error.	self should: [(Position squareForString: 'aa')] raise: Error.	self should: [(Position squareForString: 'a')] raise: Error.	self should: [(Position squareForString: '')] raise: Error.	! !TestCase subclass: #ZobristHashTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Tests'!!ZobristHashTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 15:46'!testPositionHashingPerformance	| n p1 p2 p3 p4 t |	n := 100000.	p1 := Position fromPenString: Position example21String.	p2 := Position fromPenString: Position example22String.	p3 := Position fromPenString: Position example23String.	p4 := Position fromPenString: Position example24String.	t := Time millisecondsToRun: [	n timesRepeat: [	p1 calculateHashKey. p2 calculateHashKey. p3 calculateHashKey. p4 calculateHashKey.																	p1 calculateHashKey. p2 calculateHashKey. p3 calculateHashKey. p4 calculateHashKey.																	p1 calculateHashKey. p2 calculateHashKey. p3 calculateHashKey. p4 calculateHashKey.																	p1 calculateHashKey. p2 calculateHashKey. p3 calculateHashKey. p4 calculateHashKey.																	p1 calculateHashKey. p2 calculateHashKey. p3 calculateHashKey. p4 calculateHashKey.]].	Transcript cr;show: 'Zobrish position hash test: ', (20 * n) printString, ' complete hashes in ', t printString, ' milliseconds.'	! !!ZobristHashTests methodsFor: 'tests' stamp: 'BenoitStJean 1/23/2019 13:38'!testZobristHashingPerformance	| n t |		n := 100000.	t := Time millisecondsToRun: [ 	n timesRepeat: [ 	1 to: 12 do: [ :a |																			1 to: 25 do: [ :b |	ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b. 																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.																										ZobristHash hashForStoneNumber: a square: b.]]. 																	]										 ].	Transcript cr;show: 'Zobrish hash test: ', (12 * 25 * 10 * n) printString, ' lookups in ', t printString, ' milliseconds.'! !!ZobristHashTests methodsFor: 'tests' stamp: 'BenoitStJean 1/3/2019 08:45'!testUniqueHash	| allHashValues num |		num := 12 * 25.	allHashValues := Set new: num.	ZobristHash initialize.		1 to: 12 do: [ :piece |		1 to: 25 do: [ :square | allHashValues add: (ZobristHash hashForStoneNumber: piece square: square) ] ].		self assert: allHashValues size equals: num. 	self deny: (allHashValues includes: 0).	! !Object subclass: #HashTable	instanceVariableNames: 'entries'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Internals'!!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:42'!at: key ifPresent: aBlock	^entries at: key ifPresent: aBlock	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:42'!at: aHashKey put: aMove	^entries at: aHashKey put: aMove.	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:57'!values	^entries values! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:56'!keys	^entries keys! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:42'!at: key ifAbsentPut: aBlock 	^entries at: key ifAbsentPut: aBlock 	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:38'!at: aHashKey	^entries at: aHashKey	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:42'!at: key ifPresent: oneArgBlock ifAbsent: absentBlock	^entries at: key ifPresent: oneArgBlock ifAbsent: absentBlock	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:41'!at: key ifAbsent: aBlock 	^entries at: key ifAbsent: aBlock 	! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:56'!keyAtValue: value ifAbsent: exceptionBlock	^entries keyAtValue: value ifAbsent: exceptionBlock! !!HashTable methodsFor: 'accessing' stamp: 'BenoitStJean 1/4/2019 10:56'!keyAtValue: value 	^entries keyAtValue: value ! !!HashTable methodsFor: 'private' stamp: 'BenoitStJean 1/4/2019 10:35'!setNumberOfEntriesTo: anInteger	entries := Dictionary new: anInteger	! !!HashTable methodsFor: 'testing' stamp: 'BenoitStJean 1/4/2019 10:55'!includesKey: key 	^entries includesKey: key ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HashTable class	instanceVariableNames: ''!!HashTable class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/23/2019 12:33'!new: anInteger	| anInstance |		anInstance := super new.	anInstance setNumberOfEntriesTo: anInteger.	^anInstance! !!HashTable class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/4/2019 10:32'!new	self shouldNotImplement! !Object subclass: #ZobristHash	instanceVariableNames: ''	classVariableNames: 'ZobristHash'	poolDictionaries: ''	category: 'Caerus-Internals'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ZobristHash class	instanceVariableNames: ''!!ZobristHash class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/3/2019 09:50'!hashLimit	"Maximum value :  1073741823 (30 bits).	Mostly defined that way to be able to appropriately store that info in 32 bits (unsigned) in a database!!		Note that the least 2 significant bits of this 32 bit (final) hash are reserved for <side to move> and <blue moves north>"		^(2 raisedToInteger: 30) - 1 ! !!ZobristHash class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/3/2019 09:49'!seed	"Jenny!! Jenny!! Who can I turn to?		NOTE: This seed creates distinct hash values for all piece/square combinations in the lookup table"		^8675309	! !!ZobristHash class methodsFor: 'private-initialize' stamp: 'BenoitStJean 1/3/2019 08:20'!initializeZobristHash	"self initializeZobristHash"	| rng |		rng := Random seed: self seed.	ZobristHash := Array new: 12.	1 to: 12 do: [ :stoneIndex | ZobristHash at: stoneIndex put: (Array new: 25) ].		1 to: 12 do: [:stoneZobristIndex | 		1 to: 25 do: [:square |	(ZobristHash at: stoneZobristIndex) 											at: square 											put: (rng nextInt: self hashLimit)]].	! !!ZobristHash class methodsFor: 'hashing' stamp: 'BenoitStJean 1/3/2019 08:44'!hashForStoneNumber: aStoneNumber square: aSquareIndex	^(aStoneNumber == 0)		ifTrue: [ 0 ]		ifFalse: [ (ZobristHash at: aStoneNumber) at: aSquareIndex ]! !!ZobristHash class methodsFor: 'hashing' stamp: 'BenoitStJean 1/3/2019 08:45'!hashForStone: aStone square: aSquareIndex		^aStone isNil		ifTrue: [ 0 ]		ifFalse: [ self hashForStoneNumber: aStone zobristIndex square: aSquareIndex ]! !!ZobristHash class methodsFor: 'class initialization' stamp: 'BenoitStJean 12/23/2017 21:36'!initialize	"self initialize"		self initializeZobristHash! !ZobristHash initialize!Object subclass: #CaerusPlayer	instanceVariableNames: 'moveGenerator playerName timeControl'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!CaerusPlayer methodsFor: 'sound' stamp: 'BenoitStJean 2/1/2019 22:39'!beep	DummySoundSystem current beep! !!CaerusPlayer methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/21/2019 15:52'!setPosition: aPosition	moveGenerator position: aPosition! !!CaerusPlayer methodsFor: 'accessing-derived' stamp: 'BenoitStJean 1/21/2019 16:23'!position	^moveGenerator position! !!CaerusPlayer methodsFor: 'initialize-release' stamp: 'BenoitStJean 1/21/2019 16:11'!initialize	moveGenerator := MoveGenerator new.	timeControl := NoTimeControl new.	playerName := self class defaultName.! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/3/2019 07:59'!playerName	^ playerName! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/3/2019 07:57'!moveGenerator: anObject	moveGenerator := anObject! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 02:20'!timeControl: anObject	timeControl := anObject! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/3/2019 07:57'!moveGenerator	^ moveGenerator! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/3/2019 07:59'!playerName: anObject	playerName := anObject! !!CaerusPlayer methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 02:20'!timeControl	^ timeControl! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CaerusPlayer class	instanceVariableNames: ''!!CaerusPlayer class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/9/2019 02:33'!fromPenString: aString timeControl: aTimeControl	^self fromPenString: aString timeControl: aTimeControl named: nil.! !!CaerusPlayer class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/21/2019 15:46'!new	^super new! !!CaerusPlayer class methodsFor: 'instance-creation' stamp: 'BenoitStJean 1/9/2019 02:35'!fromPenString: aString timeControl: aTimeControl named: aNameString	| pos newInstance moveGen pName |		pos := Position fromPenString: aString.	moveGen := MoveGenerator on: pos.	pName := aNameString isNil ifTrue: [ self defaultName ] ifFalse: [ aNameString ].	newInstance := super new.	newInstance moveGenerator: moveGen.	newInstance playerName: pName.	newInstance timeControl: aTimeControl.	^newInstance! !!CaerusPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:31'!defaultName	^self shouldNotImplement ! !CaerusPlayer subclass: #ComputerPlayer	instanceVariableNames: 'transpositionTable'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!ComputerPlayer methodsFor: 'initialize-release' stamp: 'BenoitStJean 1/23/2019 15:13'!initialize	super initialize.	transpositionTable := HashTable new: self class defaultHashTableSize.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ComputerPlayer class	instanceVariableNames: ''!!ComputerPlayer class methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 1/23/2019 12:30'!needsHashTable	^false! !!ComputerPlayer class methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 1/23/2019 12:30'!defaultHashTableSize	^0! !CaerusPlayer subclass: #HumanPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HumanPlayer class	instanceVariableNames: ''!!HumanPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:31'!defaultName	^'Human'! !ComputerPlayer subclass: #MonteCarloPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!MonteCarloPlayer commentStamp: 'BenoitStJean 1/9/2019 02:42' prior: 0!I score moves by randomly simulating tons of game and at the end, I choose the move with the best win percentage!!!!MonteCarloPlayer methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 2/3/2019 02:34'!getNextMove	| statsForPositions gamesSimulated numberOfSims stm originalPos updFreq |		originalPos := moveGenerator position.		"Setup basic parameters"	stm := moveGenerator position sideToMove.	numberOfSims := 10000000.	updFreq := numberOfSims // 100.	gamesSimulated := 0.		"Generate all possible moves and initialize their stats"	statsForPositions := self initializeStatistics.	UIManager default 		displayProgress: self class defaultName		from: 1 		to: numberOfSims 		during: [ :bar |	bar value: 1.																						[gamesSimulated < numberOfSims]									whileTrue: [ | indexOfStats posToSearch currentStat |																"Determine which move we are about to examine and simulate a game for"													indexOfStats := (gamesSimulated \\ statsForPositions size) + 1.																			"Make the selected move at the root of all possible moves"												 	posToSearch := originalPos copy.													moveGenerator position: posToSearch.													posToSearch makeMove: ((statsForPositions at: indexOfStats) move).													"Now, from that position, play a game until one side wins"													[posToSearch isFinal]														whileFalse: [ posToSearch makeMove: ((moveGenerator movesForRoll: 6 atRandom) atRandom) ].													"Update the stats of the move played at the root"													currentStat := statsForPositions at: indexOfStats.																posToSearch isFinal 														ifTrue: [	gamesSimulated := gamesSimulated + 1.																	(gamesSimulated \\ updFreq) = 0 ifTrue: [bar value: gamesSimulated].																	self updateGameStat: currentStat from: posToSearch.																	]												].																	statsForPositions := statsForPositions asSortedCollection: (self sortMoveStatsBlockFor: stm).								bar value: numberOfSims.					].	"The search has ended, show details on transcript and notify user with a beep!!"	self printDetailsOfPosition: originalPos on: Transcript.	self printStats: statsForPositions forColor: stm on: Transcript.	self beep.	^(statsForPositions first) move			! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/1/2019 22:50'!sortMoveStatsBlockFor: aColorSymbol	^(aColorSymbol == #BLUE) 		ifTrue: [ [ :a :b | a score > b score] ] 		ifFalse: [ [ :a :b | a score < b score] ].! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/1/2019 22:47'!updateGameStat: aStat from: aPosition	aPosition blueWins 		ifTrue: [ aStat addBlueWin ]		ifFalse: [	aPosition redWins 							ifTrue: [ aStat addRedWin ]]! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/2/2019 23:07'!printStats: statsToPrint forColor: aColorSymbol on: aStream		statsToPrint do: [ :stat |	| score |										score := (aColorSymbol = #RED) ifTrue: [ 1 - stat score ] ifFalse: [ stat score ].										aStream 											nextPutAll: stat move printString;											space;space;											nextPutAll: (score printShowingDecimalPlaces: 4);											"											tab;											nextPutAll: 'b : ', stat blueWins printString;											nextPutAll: ' r : ', stat redWins printString;											"											cr;									 		flush.					 ]! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/1/2019 23:52'!initializeStatistics	| availableMovesForPosition statsForPositions |		availableMovesForPosition := moveGenerator movesForRoll.	statsForPositions := Array new: availableMovesForPosition size.	availableMovesForPosition doWithIndex: [ :each :idx |	|  gs |																			gs := SimulatedGameStats new.																			gs move: each.																			statsForPositions at: idx put: gs ].	^statsForPositions ! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/2/2019 01:05'!printDetailsOfPosition: aPosition on: aStream	aPosition basicPrintBoardWithDetailsOn: aStream.	aStream cr;cr.! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/2/2019 00:16'!printStats: aCollectionOfMoveStats forColor: aColorSymbol! !!MonteCarloPlayer methodsFor: 'private' stamp: 'BenoitStJean 2/2/2019 00:30'!printDetailsOfPosition: aPosition	aPosition basicPrintBoardWithDetailsOn: Transcript.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MonteCarloPlayer class	instanceVariableNames: ''!!MonteCarloPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:29'!defaultName	^'Monte-Carlo'! !MonteCarloPlayer subclass: #CleverMonteCarloPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!CleverMonteCarloPlayer commentStamp: 'BenoitStJean 1/9/2019 02:42' prior: 0!I score moves by randomly simulating tons of game and at the end, I choose the move with the best win percentage!! I differ from <MonteCarloPlayer> by the fact that if there is a winning move, I play it instead of randomly picking a move!!!!CleverMonteCarloPlayer methodsFor: 'as yet unclassified' stamp: 'BenoitStJean 3/11/2019 02:50'!getNextMove	| statsForPositions gamesSimulated numberOfSims stm originalPos updFreq selectedMove availableMoves |		originalPos := moveGenerator position.		"Setup basic parameters"	stm := moveGenerator position sideToMove.	numberOfSims := 10000000.	updFreq := numberOfSims // 100.	gamesSimulated := 0.		"Generate all possible moves and initialize their stats"	statsForPositions := self initializeStatistics.	availableMoves := statsForPositions select: [ :st | (st move) isKillerFor: originalPos ].	availableMoves notEmpty ifTrue: [ statsForPositions := statsForPositions select: [ :each | each move isKillerFor: originalPos ] ].	UIManager default 		displayProgress: self class defaultName		from: 1 		to: numberOfSims 		during: [ :bar |	bar value: 1.																						[gamesSimulated < numberOfSims]									whileTrue: [ | indexOfStats posToSearch currentStat |																"Determine which move we are about to examine and simulate a game for"													indexOfStats := (gamesSimulated \\ statsForPositions size) + 1.																			"Make the selected move at the root of all possible moves"												 	posToSearch := originalPos copy.													moveGenerator position: posToSearch.													posToSearch makeMove: ((statsForPositions at: indexOfStats) move).													"Now, from that position, play a game until one side wins"													[posToSearch isFinal]														whileFalse: [ 	| possibleRandomMoves |																			possibleRandomMoves := moveGenerator movesForRoll: 6 atRandom.																			selectedMove := possibleRandomMoves 																									detect: [ :mov | mov isKillerFor: posToSearch ] 																									ifNone: [nil].																																												selectedMove isNil ifTrue: [ selectedMove := possibleRandomMoves atRandom ].																			"If it is a killer move, JUST PLAY IT !!!!!!  Otherwise, pick anything"																			posToSearch makeMove: selectedMove ].													"Update the stats of the move played at the root"													currentStat := statsForPositions at: indexOfStats.																posToSearch isFinal 														ifTrue: [	gamesSimulated := gamesSimulated + 1.																	(gamesSimulated \\ updFreq) = 0 ifTrue: [bar value: gamesSimulated].																	self updateGameStat: currentStat from: posToSearch.																	]												].																	statsForPositions := statsForPositions asSortedCollection: (self sortMoveStatsBlockFor: stm).								bar value: numberOfSims.					].	"The search has ended, show details on transcript and notify user with a beep!!"	self printDetailsOfPosition: originalPos on: Transcript.	self printStats: statsForPositions forColor: stm on: Transcript.	self beep.	^(statsForPositions first) move			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CleverMonteCarloPlayer class	instanceVariableNames: ''!!CleverMonteCarloPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:29'!defaultName	^'Monte-Carlo (Clever)'! !ComputerPlayer subclass: #RandomPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!RandomPlayer commentStamp: 'BenoitStJean 1/9/2019 02:43' prior: 0!I select my next move by randomly picking a move from the list of available moves in a position!!!!RandomPlayer methodsFor: 'moving' stamp: 'BenoitStJean 1/31/2019 11:09'!getNextMove		^moveGenerator movesForRoll atRandom! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RandomPlayer class	instanceVariableNames: ''!!RandomPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:30'!defaultName	^'Random'! !RandomPlayer subclass: #CleverRandomPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Players'!!CleverRandomPlayer commentStamp: 'BenoitStJean 1/9/2019 02:43' prior: 0!I select my next move by randomly picking a move from the list of available moves in a position!! But I differ from <RandomPlayer> by the fact that if there is a winning move, I play it instead of picking a random one!!!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CleverRandomPlayer class	instanceVariableNames: ''!!CleverRandomPlayer class methodsFor: 'accessing-constants' stamp: 'BenoitStJean 1/9/2019 02:30'!defaultName	^'Random (Clever)'! !Object subclass: #SearchControl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!SearchControl subclass: #NoTimeControl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!NoTimeControl subclass: #TimeControl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!TimeControl subclass: #CompositeTimeControl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!TimeControl subclass: #MovesPerTimeControl	instanceVariableNames: 'numberOfMoves timeInSeconds'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!MovesPerTimeControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:48'!numberOfMoves	^ numberOfMoves! !!MovesPerTimeControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:48'!numberOfMoves: anObject	numberOfMoves := anObject! !!MovesPerTimeControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:48'!timeInSeconds	^ timeInSeconds! !!MovesPerTimeControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:48'!timeInSeconds: anObject	timeInSeconds := anObject! !TimeControl subclass: #SuddenDeathControl	instanceVariableNames: 'secondsUntilEndOfGame'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!SuddenDeathControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:42'!secondsUntilEndOfGame	^ secondsUntilEndOfGame! !!SuddenDeathControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:42'!secondsUntilEndOfGame: anObject	secondsUntilEndOfGame := anObject! !TimeControl subclass: #TimePerMoveControl	instanceVariableNames: 'secondsPerMove'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!TimePerMoveControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:45'!secondsPerMove: anObject	secondsPerMove := anObject! !!TimePerMoveControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:45'!secondsPerMove	^ secondsPerMove! !TimePerMoveControl subclass: #TimePerMoveWithIncrementControl	instanceVariableNames: 'incrementInSeconds'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!TimePerMoveWithIncrementControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:45'!incrementInSeconds: anObject	incrementInSeconds := anObject! !!TimePerMoveWithIncrementControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:45'!incrementInSeconds	^ incrementInSeconds! !NoTimeControl subclass: #TimelessControl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!TimelessControl subclass: #SearchDepthControl	instanceVariableNames: 'maximumDepth'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!SearchDepthControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:41'!maximumDepth	^ maximumDepth! !!SearchDepthControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:41'!maximumDepth: anObject	maximumDepth := anObject! !TimelessControl subclass: #SimulatedGamesControl	instanceVariableNames: 'numberOfGames'	classVariableNames: ''	poolDictionaries: ''	category: 'Caerus-Controls'!!SimulatedGamesControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:49'!numberOfGames: anObject	numberOfGames := anObject! !!SimulatedGamesControl methodsFor: 'accessing' stamp: 'BenoitStJean 1/9/2019 09:49'!numberOfGames	^ numberOfGames! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.533342 pm'!!String methodsFor: '*Caerus' stamp: 'BenoitStJean 11/26/2018 16:02'!isEmptyPenString	^self = '0'! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.534342 pm'!!String methodsFor: '*Caerus' stamp: 'BenoitStJean 11/27/2018 10:31'!asSquareIndex	| column row square |		self size = 2 ifFalse: [ self error: 'Invalid square!!' ].	('abcde' includes: self first) ifFalse: [ self error: 'Invalid square column!!' ].	('12345' includes: self second) ifFalse: [ self error: 'Invalid square row!!' ].		row := (self at: 2) digitValue.	column := (self at: 1) codePoint - 96.		square := (5 * (row - 1)) + column.	^square! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.538342 pm'!!String methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 15:12'!isBluePenString	^BlueStone penAlphabet contains: [ :each | each = self ]! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.539342 pm'!!String methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 15:12'!isRedPenString	^RedStone penAlphabet contains: [ :each | each = self ]! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.540342 pm'!!Character methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 15:11'!isBluePenChar	^BlueStone penAlphabet contains: [ :each | each first = self ] ! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.541342 pm'!!Character methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 15:12'!isRedPenChar	^RedStone penAlphabet contains: [ :each | each first = self ]! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.541342 pm'!!Character methodsFor: '*Caerus' stamp: 'BenoitStJean 11/26/2018 16:15'!isEmptyPenChar	^self == $0! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.542342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 11/26/2018 15:39'!penString	^'0'! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.543342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 14:13'!displayString	^'..'! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.543342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 11/27/2018 08:32'!isRedStone	^false! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.544342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 11/26/2018 15:39'!penCharacter	^$0! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.544342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 11/27/2018 08:32'!isBlueStone	^false! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.545342 pm'!!UndefinedObject methodsFor: '*Caerus' stamp: 'BenoitStJean 11/26/2018 02:27'!isStone	^false! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.545342 pm'!!Symbol methodsFor: '*Caerus' stamp: 'BenoitStJean 1/23/2019 14:07'!oppositeColor	^(self == #BLUE)		ifTrue: [ ^#RED ]		ifFalse: [ 	(self == #RED)							ifTrue: [ ^#BLUE]							ifFalse: [self error: 'SHould not get here!!' ] ] ! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.545342 pm'!!Integer methodsFor: '*Caerus' stamp: 'BenoitStJean 11/27/2018 10:32'!asSquareIndex		(self between: 1 and: 25) ifFalse: [self error: 'Invalid square!!'].	^self! !'From Pharo5.0 of 16 April 2015 [Latest update: #50761] on 11 March 2019 at 8:57:52.546342 pm'!!Integer methodsFor: '*Caerus' stamp: 'BenoitStJean 12/10/2018 06:19'!asSquare		(self between: 1 and: 25) ifFalse: [self error: 'Invalid square!!'].	^Position stringForSquare: self! !